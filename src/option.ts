import { VOID, type Void } from "./_types.ts";
import { arrayType } from "./_utils.ts";

/**
 * An `Option` represents a value that _may not_ be present. If the value can assume either `null`
 * or `undefined`, it should be threated as _optional_.
 *
 * Interactions that modifies the state should be avoided, since there is no performant way to
 * ensure _immutability_ in `JavaScript`.
 *
 * __NOTE__: Instances of `Option` will never contain values that is iether `null` or `undefined`.
 *
 * @template T
 * Type of the value contained by the instance.
 */
export class Option<T> {
  /**
   * Instance of `Option` that does not contain a value. It avoids the creation of unecessary
   * instances every time the `Option.None` is used, since that particular instance will never
   * contain relevant data.
   */
  private static readonly emptyOption: Option<never> = new Option<never>(VOID);

  /**
   * Creates a new instance of `Option`.
   *
   * @private
   * @constructs
   *
   * @param {NonNullable<T> | Void} value
   * Value to be wrapped by the `Option`.
   */
  private constructor(
    /** The value contained by the instance. */
    private value: NonNullable<T> | Void,
  ) {}

  /**
   * Returns an instance of `Option` without value.
   *
   * @static
   * @constructs
   *
   * @returns {Option<never>}
   * An `Option` without value.
   */
  public static None(): Option<never> {
    return this.emptyOption;
  }

  /**
   * Returns an instance of `Option` containing the provided value.
   *
   * @template U
   * Type of the value.
   *
   * @param {U} value
   * Value to be wrapped.
   *
   * @returns {Option<U>}
   * An `Option` that contains the provided value.
   *
   * @returns {Option<never>}
   * An `Option` without value if receives `null` or `undefined`.
   */
  public static Some<U>(value: U): Option<U extends NonNullable<U> ? U : never>;
  public static Some<U>(value: U): Option<unknown> {
    return (value === null || value === undefined) ? Option.None() : new Option(value);
  }

  /**
   * Captures the return value of a function into an `Option`.
   *
   * @template U
   * Type of the value generated by the function.
   *
   * @param {() => U} fn
   * Function used to generate a new `Option`.
   *
   * @returns {Option<U>}
   * An `Option` containing the result of the function.
   *
   * @returns {Option<never>}
   * An `Option` without value if the result was `null`, `undefined` or an _Exception_ was thrown.
   */
  public static from<U>(fn: () => U): Option<U extends NonNullable<U> ? U : never> {
    try {
      return Option.Some(fn());
    } catch {
      return Option.None();
    }
  }

  /**
   * Converts the return value of an asynchronous function into an `Option`.
   *
   * @template U
   * Type of the value generated by the function.
   *
   * @param {() => Promise<U>} fn
   * Asynchronous function used to generate a new `Option`.
   *
   * @returns {Promise<Option<U>>}
   * An `Option` containing the result of the asynchronous function.
   *
   * @returns {Promise<Option<never>>}
   * An `Option` without value if the result was `null`, `undefined` or an _Exception_ was thrown.
   */
  public static async fromAsync<U>(
    fn: () => Promise<U>,
  ): Promise<Option<Awaited<U> extends NonNullable<Awaited<U>> ? U : never>> {
    try {
      return Option.Some(await fn());
    } catch {
      return Option.None();
    }
  }

  /**
   * Indicates if the current `Option` does not contain a value.
   *
   * @returns {boolean}
   * `true` if there is no value in the `Option`.
   */
  public get isNone(): boolean {
    return this.value === VOID;
  }

  /**
   * Indicates if the current `Option` has a value.
   *
   * @returns {boolean}
   * `true` if the `Option` contains a value.
   */
  public get isSome(): boolean {
    return this.value !== VOID;
  }

  /**
   * Returns the value of the `Option` or throws an _error_ with the given message if no value is
   * available.
   *
   * __NOTE__: This operation consumes the instance
   *
   * @param {string} errorMessage
   * Error message to indicates the absence of value in the `Option`.
   *
   * @throws {ReferenceError}
   * if the `Option` does not have a value or it was consumed.
   *
   * @returns {T}
   * The value wrapped by the `Option`.
   */
  public expect(errorMessage: string): T {
    if (this.isNone) throw new ReferenceError(errorMessage);
    return this.unwrap();
  }

  /**
   * Passes current value into the function and creates a new `Option` from its result.
   *
   * @template U
   * Type of the value generated by the function.
   *
   * @param {(value: T) => U} fn
   * Function used to generate a new `Option`.
   *
   * @returns {Option<T>}
   * If the current `Option` does not contain any value, the procedure is skipped and the current
   * instance is returned.
   *
   * @returns {Option<U>}
   * An`Option` containing the result of the function.
   *
   * @returns {Option<never>}
   * If an _Exception_ is thrown when running the function.
   */
  public map<U>(fn: (value: T) => U): Option<T | U | never> {
    if (this.isNone) return this;
    return Option.from(() => fn(this.value as T));
  }

  /**
   * Rerturns an alternative `Option` if the current instance does not contain a value.
   *
   * @param {Option<T>} fallback
   * A _fallback_ `Option` that is used if there is no value in the current instance.
   *
   * @returns {Option<T>}
   * The current instance if it contains a value, otherwise, the _fallback_ instance is used.
   */
  public or(fallback: Option<T>): Option<T> {
    return this.isSome ? this : fallback;
  }

  /**
   * Returns the value contained by the `Option`.
   *
   * __NOTE__: This operation consumes the instance
   *
   * @throws {ReferenceError}
   * If there is no value inside the instance or it was already consumed.
   *
   * @returns {T}
   * The value wrapped by the `Option`.
   */
  public unwrap(): T | never {
    if (this.isNone) {
      throw new ReferenceError("Unwrap called on a None value");
    }

    const value = this.value as T;
    this.value = VOID;

    return value;
  }

  /**
   * Provides a readable tag for `Object.prototype.toString.call`.
   *
   * @returns {string}
   * A string representation of the `Option` internal state.
   */
  public get [Symbol.toStringTag](): string {
    if (this.isNone) return "none";
    if (Array.isArray(this.value)) return `array<${arrayType(this.value)}>`;
    return typeof this.value;
  }
}
