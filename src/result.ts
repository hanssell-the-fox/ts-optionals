import { VOID, type Void } from "./_types.ts";
import { arrayType } from "./_utils.ts";

/**
 * A `Result` should represents the _outcome_ of a performed task/procedure that generated some
 * data. It can assume two possible states: __success__ (`Ok`) or a __failure__ (`Err`).
 *
 * Interactions that modifies the state fo the data should be avoided, since there is no performant
 * way to ensure _immutability_ in `JavaScript`.
 *
 * @template T
 * Type of the value generated by the action when it was a success.
 *
 * @template E
 * Type of the error if it failed.
 */
export class Result<T, E = Error> {
  /**
   * Indicates if the value in the instance was consumed.
   */
  private consumed: boolean = false;

  /**
   * Constructs a new instance of `Result`.
   *
   * @private
   * @constructs
   *
   * @param {T | E} value
   * The value contained by the `Result`. It can be either a valid data or an error.
   *
   * @param {Boolean} [isError=false]
   * Identifies the instance as containing an error.
   */
  private constructor(
    /** Holds a value or an error. */
    private value: T | E | Void,
    /** Helper that indicates the type of the instance. */
    private isError: boolean = false,
  ) {
  }

  /**
   * Creates a `Result` that contains an error.
   *
   * @constructs
   * @static
   *
   * @template U
   * Type of the `Error`.
   *
   * @param {U} cause
   * The cause/value of the error.
   *
   * @returns {Result<never, U>}
   * A `Result` containing an error.
   */
  public static Err<U>(cause: U): Result<never, U> {
    return new Result<never, U>(cause, true);
  }

  /**
   * Creates a `Result` that contains valid data.
   *
   * @constructs
   * @static
   *
   * @template U
   * Type of the data.
   *
   * @template V
   * Type of the error expected.
   *
   * @param {U} value
   * The data to be contained by the `Result`.
   *
   * @returns {Result<U, V>}
   * A `Result` that contains some data.
   */
  public static Ok<U, V = U>(value: U): Result<U, V> {
    return new Result<U, V>(value);
  }

  /**
   * Returns the value of the `Result`, or throws an error with a custom message.
   *
   * __NOTE__: This operation consumes the instance.
   *
   * @throws {ReferenceError}
   * If the current instance contains an _error_ or was consumed.
   *
   * @param {string} errorMessage
   * Message to describe the error.
   *
   * @returns {T}
   * The data contained by `Result`.
   */
  public expect(errorMessage: string): T | never {
    if (this.isErr) throw new ReferenceError(errorMessage);
    return this.unwrap();
  }

  /**
   * Captures the result of a function into an `Result`.
   *
   * @constructs
   * @static
   *
   * @template U
   * The type of the value generated by the function.
   *
   * @param {() => U} fn
   * The function used to generate the value.
   *
   * @returns {Promise<Result<U, E>>}
   * A `Result` containing the result of the function.
   *
   * @returns {Promise<Result<never, E>>}
   * A `Result` that contains an error if an _exception_ was thrown.
   */
  public static from<U = never, E = Error>(fn: () => U): Result<U, E> {
    try {
      return Result.Ok<U, E>(fn());
    } catch (error) {
      return Result.Err(error as E);
    }
  }

  /**
   * Captures the result of an asynchronous function into an `Result`.
   *
   * @constructs
   * @static
   *
   * @template U
   * The type of the value generated by the function.
   *
   * @param {() => Promise<U>} fn
   * The function used to generate the value for the `Result`.
   *
   * @returns {Promise<Result<U, E>>}
   * A `Result` containing the result of the asynchronous function.
   *
   * @returns {Promise<Result<never, E>>}
   * A `Result` that contains an error if an _exception_ was thrown.
   */
  public static async fromAsync<U = never, E = Error>(fn: () => Promise<U>): Promise<Result<U, E>> {
    try {
      return Result.Ok<U, E>(await fn());
    } catch (error) {
      return Result.Err(error as E);
    }
  }

  /**
   * Indicates if the `Result` contains a value.
   *
   * @returns {Boolean}
   * `true` if it contains a valid value.
   */
  public get isOk(): boolean {
    return !this.consumed && !this.isError;
  }

  /**
   * Indicates if the `Result` is an error.
   *
   * @returns {Boolean}
   * `true` if it is an error.
   */
  public get isErr(): boolean {
    return !this.consumed && this.isError;
  }

  /**
   * Passes the value of the `Result` into the function and uses its return value to create a new
   * `Result`.
   *
   * @template U
   * The type of the value generated by the function.
   *
   * @param {(okValue: T) => U} fn
   * The function used to generate a new value.
   *
   * @returns {Result<T, E>}
   * The current instance of `Result` if it is a _error_ or does not contain a value.
   *
   * @returns {Result<U, E>}
   * A new `Result` containing the result of the function.
   *
   * @returns {Result<never, unknown>}
   * If an _Exception_ was thrown inside the function
   */
  public map<U, V>(fn: (okValue: T) => U): Result<T | U, E | V> {
    return this.isErr ? this : Result.from(() => fn(this.value as T));
  }

  /**
   * Returns the _fallback_ `Result` if the current one is an error or was consumed.
   *
   * @param {Result<T, E>} fallback
   * The alternative `Result`.
   *
   * @returns {Result<T, E>}
   * The current `Result` or the provided fallback.
   */
  public or(fallback: Result<T, E>): Result<T, E> {
    return this.isOk ? this : fallback;
  }

  /**
   * Returns the value contained by the `Result` and invalidates the instance.
   *
   * __NOTE__: This operation consumes the instance.
   *
   * @throws {ReferenceError}
   * If the value is an error or was consumed.
   *
   * @returns {T}
   * The value contained by the `Result`.
   */
  public unwrap(): T | never {
    if (this.consumed) throw new ReferenceError("The instance was consumed");
    if (this.isErr) throw new ReferenceError("Called unwrap on an Err value");
    return this.getValueAndInvalidate() as T;
  }

  /**
   * Returns the content of the error in the `Result`.
   *
   * @throws {ReferenceError}
   * If called on an `Result` that contains an `Ok` value.
   *
   * @returns {string}
   * The error message contained in the `Result`.
   */
  public unwrapErr(): E | never {
    if (this.consumed) throw new ReferenceError("The instance was consumed");
    if (this.isOk) throw new ReferenceError("Called unwrapErr on an Ok value");
    return this.getValueAndInvalidate() as E;
  }

  /**
   * Provides a readable tag for `Object.prototype.toString.call`.
   *
   * @returns {string}
   * A string representation of the `Result` internal state.
   */
  public get [Symbol.toStringTag](): string {
    if (this.consumed) return "consumed";

    const instanceType: string = this.isOk ? "ok" : "error";
    if (Array.isArray(this.value)) return `${instanceType}<array<${arrayType(this.value)}>>`;
    return `${instanceType}<${typeof this.value}>`;
  }

  /**
   * Marks the instance as consumed.
   *
   * @returns {T | E}
   * The value contained by the `instance`.
   */
  private getValueAndInvalidate(): T | E {
    const value = this.value;
    this.value = VOID;
    this.consumed = true;
    return value as T | E;
  }
}
