// deno-lint-ignore-file no-explicit-any

import { Infer } from "./_types.ts";
import { getArrayType } from "./_utils.ts";

/**
 * Represents the state of _absolute nothing_ in an instance of `Result`.
 * Used as a __hint__ to know when the instance has been "consumed".
 */
const VOID: unique symbol = Symbol("void");

/**
 * Extracts the original type used as value on nested `Results`.
 *
 * @example
 * ```ts
 * const ok: Result<number, string> = Result.Ok(10);
 * //                 ^
 * //             This type
 * ```
 */
type BaseValue<T> = T extends Result<infer Inner, any>
  ? Inner extends Result<any, any> ? BaseValue<Inner> : Inner
  : T;

/**
 * Extracts the original error type of nested `Results`.
 *
 * @example
 * ```ts
 * const ok: Result<number, string> = Result.Ok(10);
 * //                         ^
 * //                     This type
 * ```
 */
type BaseError<T> = T extends Result<any, infer Err>
  ? Err extends Result<any, any> ? BaseError<Err> : Err
  : T;

/**
 * Extracts the original `Result` type from the _first_ instance (the very beggining) of
 * nested `Results`. Used to infer the expected type for values in some of the procedures.
 */
type FlattenedResult<T> = T extends Result<any, any>
  ? Result<BaseValue<T>, BaseError<T>>
  : never;

/**
 * Represents an __outcome__, or better, a value that resulted from the completion os some
 * performed _action_. Very usefull, indeed.
 *
 * @template T The type of the value generated by the action.
 * @template E The type of the error that ocurred, if it is an _Error_.
 */
export class Result<T, E> {
  /** Holds a value, an error, or the _absolute nothingness of the void_. */
  #value: T | E | typeof VOID;
  /** Helps to tell if it is an error. */
  #error: boolean;

  /**
   * _(DO NOT USE OUTSIDE OF THIS CLASS, seriously...)_
   *
   * Constructs a new instance of `Result`.
   * Use `Result.Ok` or `Result.Err` to construct objects, since this `constructor` _does
   * not_ make any those type-checking shenanigans.
   *
   * @private
   * @param {T} value The value holded by the `Result`.
   * @param {Boolean} [isError=false] Identifies the instance as containing an error.
   */
  private constructor(value: T | E, isError: boolean = false) {
    this.#value = value;
    this.#error = isError;
  }

  /**
   * Creates an instance of `Result` that contains and error with the provided "cause".
   *
   * @constructs
   * @static
   * @template U The type of the `Err` holded by the instance.
   * @param {U} cause The cause/value of the error.
   * @returns {Result<never, U>} An instance of `Result` which the value is an error.
   */
  public static Err<U>(cause: NonNullable<U>): Result<never, Infer<U>> {
    return new Result<never, U>(cause, true) as Result<never, Infer<U>>;
  }

  /**
   * Creates an instance of `Result` that constains the provided value.
   * When receives `null` or `undefined`, automatically returns an instance of `Err`.
   *
   * @constructs
   * @static
   * @template U The type of the value for the `Result`.
   * @template V The type of the error expect for the `Result`.
   * @param {U} value The value contained by the `Result`.
   * @returns {Result<NonNullable<U> | never, V>} An instance of `Result` that contains a value.
   */
  public static Ok<U, V = U>(value: U): Result<NonNullable<U> | never, V> {
    // deno-fmt-ignore
    return (value === null || value === undefined)
      ? new Result<never, string>( `Value of type "${value}"`, true) as Result<never, V>
      : new Result<NonNullable<U>, V>(value as NonNullable<U>);
  }

  /**
   * Returns the value of the `Result`, or throws an error with the provided message/cause.
   * (Consumes the Result)
   *
   * @param {string} message The message to be used to describe the error.
   * @returns {T} The value contained in the `Result`.
   */
  public expect(message: string): T | never {
    if (this.isErr) throw new ReferenceError(message);
    return this.unwrap;
  }

  /**
   * Flattens nested _Results_, returning the original `Result`.
   *
   * @returns {Result<T, E>} A flattened Result containg the original _Result_.
   */
  public get flatten(): FlattenedResult<T> {
    const value = (this.isOk && this.#value instanceof Result)
      ? this.#value.flatten
      : this;

    return value as unknown as FlattenedResult<T>;
  }

  /**
   * Executes a function, capturing its _output_ into an `Ok` instance of Result, or _raised_
   * errors into an `Err` instance.
   *
   * @constructs
   * @static
   * @template U The type of the value generated by the function.
   * @param {() => U} fn The function used to generate the value for the `Result`.
   * @returns {Result<U, E>} An `Result` containing the generated value.
   */
  public static from<U = never, E = Error>(fn: () => U): Result<U, Infer<E>> {
    try {
      return Result.Ok<U, Infer<E>>(fn());
    } catch (error) {
      return (error === undefined || error === null)
        ? Result.Ok(undefined)
        : Result.Err(error as NonNullable<E>);
    }
  }

  /**
   * Executes an _async function_, capturing its output into an `Ok` instance of result, or
   * _raised_ errors into an `Err` instance. Similar to `Result.from`, but async.
   *
   * @constructs
   * @static
   * @template U The type of the value generated by the function.
   * @param {() => Promise<U>} fn The function used to generate the value for the `Result`.
   * @returns {Promise<Result<U, E>>} An `Result` containing the generated value.
   */
  public static async fromAsync<U = never, E = Error>(
    fn: () => Promise<U>,
  ): Promise<Result<U, Infer<E>>> {
    try {
      return Result.Ok<U, Infer<E>>(await fn());
    } catch (error) {
      return (error === undefined || error === null)
        ? Result.Ok(undefined)
        : Result.Err(error as NonNullable<E>);
    }
  }

  /**
   * Indicates where the `Result` contains a valid value, or not.
   *
   * @returns {Boolean} `true` if it contains a valid data.
   */
  public get isOk(): boolean {
    return !this.isErr;
  }

  /**
   * Indicates where the `Result` is an error.
   *
   * @returns {Boolean} `true` if it is an error.
   */
  public get isErr(): boolean {
    return this.#error;
  }

  /**
   * Applies a function to the value in the Result. The value returned by the function is used
   * to create a new `Result`.
   *
   * If the current Result is an `Err`, the function is ignored and the current instance is
   * returned instead.
   *
   * @template U The type of the value generated by the transformer.
   * @param {(okValue: T) => U} fn The function to transform the value.
   * @returns {Result<U, E> | this} A `Result` containing the transformed value or the current instance
   * if no value is present.
   */
  public map<U>(fn: (okValue: T) => U): Result<U, E> | this {
    if (this.isErr) return this;
    return new Result<U, E>(fn(this.#value as T));
  }

  /**
   * Applies a function to the value in the Result. The value returned by the function is used
   * to create a new `Result`.
   *
   * If the current Result is an `Err`, the function is ignored and the value provided as _default_
   * will be used to create a new `Result` instead.
   *
   * @template U The type of the default value.
   * @param {U} defaultValue The default value to return if the contained value is an `Err`.
   * @param {(okValue: T) => U} fn The function to transform the value.
   * @returns {Result<U, E>} A `Result` containing the mapped value or the default value.
   */
  public mapOr<U>(defaultValue: U, fn: (okValue: T) => U): Result<U, E> {
    if (this.isErr) return new Result<U, E>(defaultValue);
    return this.map<U>(fn) as Result<U, E>;
  }

  /**
   * Returns the provided `Result` as the fallback if the current one is an error.
   *
   * @param {Result<T, E>} fallback The value returned if the current is an error.
   * @returns {Result<T, E>} The current `Result` of the provided fallback.
   */
  public or(fallback: Result<T, E>): Result<T, E> {
    return this.isErr ? fallback : this;
  }

  /**
   * Returns the value contained by the `Result` and invalidates the instance.
   * (Consumes the Result)
   *
   * @returns {T | never} The value contained by the `Result`.
   * @throws {ReferenceError} If the value is an error.
   */
  public get unwrap(): T | never {
    if (this.isErr) throw new ReferenceError("Called unwrap on an Err value");

    const currentValue = this.#value;
    this.#error = true;
    this.#value = VOID;
    return currentValue as T;
  }

  /**
   * Returns the value contained by the `Result`, or returns the value provided as _default_.
   * (Consumes the Result)
   *
   * @template U The type of the value provided as default (same as the one defined in the Result).
   * @param {U} defaultValue The value used as default if the `Result` does not contain a value.
   * @returns {T | U | never} The value contained by the `Result` or the provided default.
   */
  public unwrapOr<U>(defaultValue: U): T | Infer<U> {
    return this.isOk ? this.unwrap : defaultValue as Infer<U>;
  }

  /**
   * Returns the value contained by the `Result`, or returns the value computed by using the provided
   * function.
   * (Consumes the Result)
   *
   * @template U The type of the value generated by the function (same as the one defined in the Result).
   * @param {() => U} fn The function used to compute the value, if the `Result` does not contain a value.
   * @returns {T | U | never} The value contained by the `Result` or the computed one.
   */
  public unwrapOrElse<U>(fn: () => U): T | Infer<U> {
    return this.isOk ? this.unwrap : fn() as Infer<U>;
  }

  /**
   * Returns the content of the error in the `Result`. Fails if the Result is not an error.
   *
   * @returns {string} The error message contained in the `Result`.
   * @throws {ReferenceError} If called on an `Ok` value.
   */
  public get unwrapErr(): E | never {
    if (this.isOk) throw new ReferenceError("Called unwrapErr on an Ok value");
    return this.#value as E;
  }

  /**
   * _(UNSAFE)_
   * Exposes the value in the `Result` to be consulted, and should not be used aside of debugging purposes.
   *
   * @returns {Readonly<T | E>} The value contained in the `Result`.
   */
  public get peek(): Readonly<T | E> | typeof VOID {
    return this.#value;
  }

  /**
   * Provides a human-readable tag for `Object.prototype.toString.call`.
   *
   * @returns {string} A string representation of the `Result` state.
   */
  public get [Symbol.toStringTag](): string {
    const valueType = Array.isArray(this.#value)
      ? `${getArrayType(this.#value)}[]`
      : typeof this.#value;

    const type = `${this.isErr ? "error" : "ok"}<${valueType}>`;
    return `Result<${type}>`;
  }
}
